(** Atomyst CLI entry point.

    Atomize Python source files into one-definition-per-file structure.
*)

open Cmdliner
open Atomyst

let version = "0.1.0"

(** Read file contents *)
let read_file path =
  let ic = open_in path in
  let n = in_channel_length ic in
  let s = really_input_string ic n in
  close_in ic;
  s

(** Write file contents, creating parent directories if needed *)
let write_file path content =
  let dir = Filename.dirname path in
  if not (Sys.file_exists dir) then
    ignore (Sys.command (Printf.sprintf "mkdir -p %s" (Filename.quote dir)));
  let oc = open_out path in
  output_string oc content;
  close_out oc

(** Build __init__.py content for a list of definitions *)
let build_init_file definitions =
  let buf = Buffer.create 256 in
  Buffer.add_string buf {|"""Auto-generated by atomyst."""|};
  Buffer.add_string buf "\n\n";
  List.iter (fun (d : Types.definition) ->
    let stem = Snake_case.to_snake_case d.name in
    Buffer.add_string buf (Printf.sprintf "from .%s import %s\n" stem d.name)
  ) definitions;
  Buffer.add_string buf "\n__all__ = [\n";
  List.iter (fun (d : Types.definition) ->
    Buffer.add_string buf (Printf.sprintf "    \"%s\",\n" d.name)
  ) definitions;
  Buffer.add_string buf "]\n";
  { Types.relative_path = "__init__.py"; content = Buffer.contents buf }

(** Plan atomization of a source file *)
let plan_atomization source source_name =
  let lines =
    let parts = String.split_on_char '\n' source in
    let parts =
      if String.length source > 0 && source.[String.length source - 1] = '\n' then
        match List.rev parts with
        | "" :: rest -> List.rev rest
        | _ -> parts
      else parts
    in
    List.map (fun s -> s ^ "\n") parts
  in
  let definitions = Extract.extract_definitions source in
  let import_lines = Extract.extract_imports lines in
  let import_block = String.concat "" import_lines in

  let output_files =
    List.map (fun (defn : Types.definition) ->
      let arr = Array.of_list lines in
      let actual_start =
        (* find_comment_start logic *)
        let rec scan idx =
          if idx < 0 then idx + 2
          else
            let stripped = String.trim arr.(idx) in
            if String.length stripped > 0 && stripped.[0] = '#' then scan (idx - 1)
            else if stripped = "" then idx + 2
            else idx + 2
        in
        scan (defn.start_line - 2)
      in
      let defn_lines =
        Array.sub arr (actual_start - 1) (defn.end_line - actual_start + 1)
        |> Array.to_list
      in
      let defn_content = String.concat "" defn_lines in
      let trimmed =
        let s = defn_content in
        let len = String.length s in
        let rec find_start i =
          if i >= len then len
          else if s.[i] = '\n' then find_start (i + 1)
          else i
        in
        String.sub s (find_start 0) (len - find_start 0)
      in
      let content = import_block ^ "\n\n" ^ trimmed in
      let filename = Snake_case.to_snake_case defn.name ^ ".py" in
      { Types.relative_path = filename; content }
    ) definitions
  in
  let init_file = build_init_file definitions in
  { Types.source_name; definitions; output_files = output_files @ [init_file] }

(** Run atomization *)
let run_atomize source_path output_dir dry_run format_opt =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in
    let source_name = Filename.basename source_path in
    let plan = plan_atomization source source_name in

    if plan.definitions = [] then begin
      print_endline (Printf.sprintf "No definitions found in %s" source_path);
      0
    end else begin
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None ->
          let stem = Filename.remove_extension source_path in
          stem
      in

      if not dry_run then begin
        List.iter (fun (f : Types.output_file) ->
          let path = Filename.concat resolved_output_dir f.relative_path in
          write_file path f.content
        ) plan.output_files
      end;

      let output = match format_opt with
        | "json" -> Render.plan_json plan
        | _ ->
          let text = Render.plan_text plan in
          if dry_run then
            text ^ "\n\n[DRY RUN] No files written."
          else
            text ^ Printf.sprintf "\n\nCreated %d files in %s/"
              (List.length plan.output_files) resolved_output_dir
      in
      print_endline output;
      0
    end
  end

(** Run single extraction *)
let run_extract source_path name output_dir dry_run format_opt =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in

    match Extract.extract_one source name with
    | None ->
      print_endline (Render.error (Printf.sprintf "Definition '%s' not found in %s" name source_path));
      1
    | Some result ->
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None -> Sys.getcwd ()
      in

      if not dry_run then begin
        let path = Filename.concat resolved_output_dir result.extracted.relative_path in
        write_file path result.extracted.content
      end;

      let output = match format_opt with
        | "json" -> Render.extraction_json result ~name
        | _ -> Render.extraction_text result ~name ~dry_run
      in
      print_endline output;
      0
  end

(** Main entry point *)
let main source_path output_dir dry_run format_opt extract_name =
  match extract_name with
  | Some name -> run_extract source_path name output_dir dry_run format_opt
  | None -> run_atomize source_path output_dir dry_run format_opt

(* Cmdliner terms *)

let source_arg =
  let doc = "Source file to atomize" in
  Arg.(required & pos 0 (some string) None & info [] ~docv:"SOURCE" ~doc)

let output_arg =
  let doc = "Output directory (default: <source_stem>/)" in
  Arg.(value & opt (some string) None & info ["o"; "output"] ~docv:"DIR" ~doc)

let dry_run_arg =
  let doc = "Show what would be created without writing files" in
  Arg.(value & flag & info ["dry-run"] ~doc)

let format_arg =
  let doc = "Output format (text or json)" in
  Arg.(value & opt string "text" & info ["format"] ~docv:"FORMAT" ~doc)

let extract_arg =
  let doc = "Extract a single definition by name (incremental mode)" in
  Arg.(value & opt (some string) None & info ["extract"] ~docv:"NAME" ~doc)

let cmd =
  let doc = "Atomize Python source files into one-definition-per-file structure" in
  let info = Cmd.info "atomyst" ~version ~doc in
  let term = Term.(const main $ source_arg $ output_arg $ dry_run_arg $ format_arg $ extract_arg) in
  Cmd.v info term

let () =
  match Cmd.eval_value cmd with
  | Ok (`Ok exit_code) -> exit exit_code
  | Ok `Version | Ok `Help -> exit 0
  | Error _ -> exit 1
