(** Atomyst CLI entry point.

    Atomize Python source files into one-definition-per-file structure.
*)

open Cmdliner
open Atomyst

let version = "%%VERSION_NUM%%"

(* ============================================================================
   Atomization Metadata Configuration
   ============================================================================
   These values are embedded in generated __init__.py files.
   Edit here to customize the output.
*)

let tool_name = "atomyst"
let tool_url = "https://github.com/m-gris/atomyst"

(** The micro-manifesto: why atomic file structure matters *)
let manifesto = {|Large files are hostile to AI agents—they read everything to edit anything.
One definition per file. Atomic edits. No collisions.
`tree src/` reveals the architecture at a glance.|}

(** Format the metadata block for __init__.py docstrings.
    @param source_name Original source file name
    @param timestamp ISO 8601 timestamp
    @return Formatted metadata string *)
let format_metadata ~source_name ~timestamp =
  Printf.sprintf {|---
%s <%s>
Source: %s | %s

%s|}
    tool_name tool_url source_name timestamp manifesto

(** Read file contents *)
let read_file path =
  let ic = open_in path in
  let n = in_channel_length ic in
  let s = really_input_string ic n in
  close_in ic;
  s

(** Write file contents, creating parent directories if needed *)
let write_file path content =
  let dir = Filename.dirname path in
  if not (Sys.file_exists dir) then
    ignore (Sys.command (Printf.sprintf "mkdir -p %s" (Filename.quote dir)));
  let oc = open_out path in
  output_string oc content;
  close_out oc

(** Run ruff to clean up unused imports. Silent if ruff not available. *)
let cleanup_unused_imports dir =
  let cmd = Printf.sprintf "ruff check --fix --select=F401 %s >/dev/null 2>&1"
    (Filename.quote dir) in
  ignore (Sys.command cmd)

(** Handle original file after atomization.
    Default: remove if safe (git-tracked, no uncommitted changes).
    With --keep-original: always keep. *)
let handle_original_file ~keep_original source_path =
  if keep_original then
    print_endline (Printf.sprintf "\n→ Original file kept (--keep-original): %s" source_path)
  else
    match Git_utils.check_safe_to_remove source_path with
    | Git_utils.Safe ->
      Sys.remove source_path;
      print_endline (Printf.sprintf "\n✓ Removed original file: %s" source_path)
    | Git_utils.NotInRepo ->
      print_endline (Printf.sprintf "\n→ Original file kept: not in a git repository")
    | Git_utils.NotTracked ->
      print_endline (Printf.sprintf "\n→ Original file kept: not tracked by git")
    | Git_utils.HasUncommittedChanges ->
      print_endline (Printf.sprintf "\n→ Original file kept: has uncommitted changes")

(** Build __init__.py content for a single definition by name *)
let build_single_init name =
  let buf = Buffer.create 256 in
  Buffer.add_string buf {|"""Auto-generated by atomyst."""|};
  Buffer.add_string buf "\n\n";
  let stem = Snake_case.to_snake_case name in
  Buffer.add_string buf (Printf.sprintf "from .%s import %s\n" stem name);
  Buffer.add_string buf "\n__all__ = [\n";
  Buffer.add_string buf (Printf.sprintf "    \"%s\",\n" name);
  Buffer.add_string buf "]\n";
  Buffer.contents buf

(** Format timestamp as ISO 8601 *)
let format_timestamp () =
  let t = Unix.gettimeofday () in
  let tm = Unix.gmtime t in
  Printf.sprintf "%04d-%02d-%02dT%02d:%02d:%02dZ"
    (tm.Unix.tm_year + 1900) (tm.Unix.tm_mon + 1) tm.Unix.tm_mday
    tm.Unix.tm_hour tm.Unix.tm_min tm.Unix.tm_sec

(** Build __init__.py content for a list of definitions.
    Preserves original module docstring if provided, adds atomization metadata. *)
let build_init_file ~source_name ~docstring ~prefix_kind definitions =
  let buf = Buffer.create 512 in
  let timestamp = format_timestamp () in
  let metadata = format_metadata ~source_name ~timestamp in
  (* Docstring: use original if available, otherwise generate *)
  (match docstring with
   | Some ds ->
     (* Original docstring - add atomization metadata at the end *)
     let ds_trimmed = String.trim ds in
     let has_triple_quotes =
       String.length ds_trimmed >= 6 &&
       (String.sub ds_trimmed 0 3 = {|"""|} || String.sub ds_trimmed 0 3 = "'''")
     in
     if has_triple_quotes then begin
       (* Find the closing quotes and insert metadata before them *)
       let delim = String.sub ds_trimmed 0 3 in
       let inner_start = 3 in
       let inner_end = String.length ds_trimmed - 3 in
       let inner = String.sub ds_trimmed inner_start (inner_end - inner_start) in
       let inner_trimmed = String.trim inner in
       Buffer.add_string buf delim;
       Buffer.add_string buf inner_trimmed;
       if inner_trimmed <> "" then Buffer.add_string buf "\n\n";
       Buffer.add_string buf metadata;
       Buffer.add_string buf "\n";
       Buffer.add_string buf delim
     end else begin
       (* Malformed docstring, just use as-is *)
       Buffer.add_string buf ds_trimmed
     end
   | None ->
     (* No original docstring - generate metadata-only docstring *)
     Buffer.add_string buf {|"""|};
     Buffer.add_string buf metadata;
     Buffer.add_string buf "\n";
     Buffer.add_string buf {|"""|});
  Buffer.add_string buf "\n\n";
  (* Imports *)
  List.iter (fun (d : Types.definition) ->
    let stem = Filename.remove_extension (Prefix.generate_filename ~prefix_kind d) in
    Buffer.add_string buf (Printf.sprintf "from .%s import %s\n" stem d.name)
  ) definitions;
  (* __all__ *)
  Buffer.add_string buf "\n__all__ = [\n";
  List.iter (fun (d : Types.definition) ->
    Buffer.add_string buf (Printf.sprintf "    \"%s\",\n" d.name)
  ) definitions;
  Buffer.add_string buf "]\n";
  { Types.relative_path = "__init__.py"; content = Buffer.contents buf }

(** Detect potential re-exports: names imported but not defined.
    These won't be available from the generated __init__.py. *)
let detect_potential_reexports import_lines definitions =
  let parsed = Extract.parse_import_names import_lines in
  let defined_names = List.map (fun (d : Types.definition) -> d.name) definitions in
  (* Any import that isn't a definition could be a re-export *)
  List.filter (fun (imp : Extract.parsed_import) ->
    not (List.mem imp.name defined_names)
  ) parsed

(** Build _constants.py content from constants and import block.
    Pure function: assembles the file content.
    Detects references to sibling definitions and generates imports for them. *)
let build_constants_file ~import_block ~constants ~definitions ~prefix_kind =
  if constants = [] then None
  else
    (* Combine all constant source texts to find sibling references *)
    let all_constants_text = String.concat "\n"
      (List.map (fun (c : Python_parser.module_constant) -> c.source_text) constants) in
    let defn_names = List.map (fun (d : Types.definition) -> d.name) definitions in
    let referenced_defns = Extract.find_constant_references
      ~constant_names:defn_names ~defn_content:all_constants_text in
    (* Generate sibling imports with kind prefix when enabled *)
    let sibling_imports = List.filter_map (fun name ->
      List.find_opt (fun (d : Types.definition) -> d.name = name) definitions
      |> Option.map (fun d ->
        let stem = Filename.remove_extension (Prefix.generate_filename ~prefix_kind d) in
        Printf.sprintf "from .%s import %s\n" stem d.name)
    ) referenced_defns in

    let buf = Buffer.create 512 in
    Buffer.add_string buf {|"""Module-level constants extracted by atomyst."""|};
    Buffer.add_string buf "\n\n";
    (* Add import block if non-empty *)
    if String.trim import_block <> "" then begin
      Buffer.add_string buf import_block;
      if not (String.ends_with ~suffix:"\n" import_block) then
        Buffer.add_string buf "\n";
      Buffer.add_string buf "\n"
    end;
    (* Add sibling imports for referenced definitions *)
    List.iter (fun line -> Buffer.add_string buf line) sibling_imports;
    if sibling_imports <> [] then Buffer.add_string buf "\n";
    (* Add each constant's source text *)
    List.iter (fun (c : Python_parser.module_constant) ->
      Buffer.add_string buf c.source_text;
      if not (String.ends_with ~suffix:"\n" c.source_text) then
        Buffer.add_string buf "\n"
    ) constants;
    Some { Types.relative_path = "_constants.py"; content = Buffer.contents buf }

(** Detect which constants are referenced by each definition.
    Returns a list of (definition_name, [constant_names]) pairs.
    Pure function: analysis only, no side effects. *)
let detect_constant_references source definitions =
  let constants = Python_parser.extract_constants source in
  let constant_names = List.map (fun (c : Python_parser.module_constant) -> c.name) constants in
  if constant_names = [] then []
  else
    let lines =
      let parts = String.split_on_char '\n' source in
      let parts =
        if String.length source > 0 && source.[String.length source - 1] = '\n' then
          match List.rev parts with
          | "" :: rest -> List.rev rest
          | _ -> parts
        else parts
      in
      List.map (fun s -> s ^ "\n") parts
    in
    let arr = Array.of_list lines in
    List.filter_map (fun (defn : Types.definition) ->
      let defn_lines = Array.sub arr (defn.start_line - 1) (defn.end_line - defn.start_line + 1) in
      let defn_content = String.concat "" (Array.to_list defn_lines) in
      let refs = Extract.find_constant_references ~constant_names ~defn_content in
      if refs = [] then None
      else Some (defn.name, refs)
    ) definitions

(** Plan atomization of a source file. Returns (plan, skipped_docstring, skipped_pragmas, potential_reexports, constant_refs) *)
let plan_atomization source source_name ~keep_pragmas ~prefix_kind =
  let lines =
    let parts = String.split_on_char '\n' source in
    let parts =
      if String.length source > 0 && source.[String.length source - 1] = '\n' then
        match List.rev parts with
        | "" :: rest -> List.rev rest
        | _ -> parts
      else parts
    in
    List.map (fun s -> s ^ "\n") parts
  in
  let definitions = Extract.extract_definitions source in
  let import_result = Extract.extract_imports_full ~keep_pragmas lines in
  let potential_reexports = detect_potential_reexports import_result.lines definitions in
  (* Adjust relative imports: when extracting foo.py to foo/, we go 1 level deeper *)
  let adjusted_lines = Extract.adjust_relative_imports ~depth_delta:1 import_result.lines in
  let import_block = String.concat "" adjusted_lines in

  (* Extract module-level constants *)
  let constants = Python_parser.extract_constants source in
  let constant_names = List.map (fun (c : Python_parser.module_constant) -> c.name) constants in

  (* Extract logger bindings - these depend on __name__ and must be replicated per-file *)
  let logger_bindings = Python_parser.extract_logger_bindings source in
  let logger_var_names = List.map (fun (lb : Python_parser.logger_binding) -> lb.var_name) logger_bindings in

  let output_files =
    List.map (fun (defn : Types.definition) ->
      let arr = Array.of_list lines in
      let actual_start =
        (* find_comment_start logic *)
        let rec scan idx =
          if idx < 0 then idx + 2
          else
            let stripped = String.trim arr.(idx) in
            if String.length stripped > 0 && stripped.[0] = '#' then scan (idx - 1)
            else if stripped = "" then idx + 2
            else idx + 2
        in
        scan (defn.start_line - 2)
      in
      let defn_lines =
        Array.sub arr (actual_start - 1) (defn.end_line - actual_start + 1)
        |> Array.to_list
      in
      (* Adjust relative imports inside definition body (depth_delta=1 for extraction to subdir) *)
      let adjusted_defn_lines = Extract.adjust_relative_imports ~depth_delta:1 defn_lines in
      let defn_content = String.concat "" adjusted_defn_lines in
      (* Find sibling references and generate imports *)
      let sibling_names = Extract.find_sibling_references ~all_defns:definitions ~target_defn:defn ~defn_content in
      let sibling_import_lines = Extract.generate_sibling_imports sibling_names in
      let sibling_imports = String.concat "" sibling_import_lines in
      (* Find constant references and generate imports *)
      let const_refs = Extract.find_constant_references ~constant_names ~defn_content in
      let const_import =
        if const_refs = [] then ""
        else Printf.sprintf "from ._constants import %s\n" (String.concat ", " const_refs)
      in
      (* Find logger references and generate per-file logger bindings *)
      let logger_refs = Extract.find_constant_references ~constant_names:logger_var_names ~defn_content in
      let logger_lines =
        if logger_refs = [] then ""
        else
          let binding_texts = List.filter_map (fun var_name ->
            List.find_opt (fun (lb : Python_parser.logger_binding) -> lb.var_name = var_name) logger_bindings
            |> Option.map (fun (lb : Python_parser.logger_binding) -> lb.source_text)
          ) logger_refs in
          String.concat "" binding_texts
      in
      let trimmed =
        let s = defn_content in
        let len = String.length s in
        let rec find_start i =
          if i >= len then len
          else if s.[i] = '\n' then find_start (i + 1)
          else i
        in
        String.sub s (find_start 0) (len - find_start 0)
      in
      (* Combine: original imports + sibling imports + constant imports + logger bindings + definition *)
      let imports_section =
        let base = if sibling_imports = "" then import_block else import_block ^ sibling_imports in
        if const_import = "" then base else base ^ const_import
      in
      (* Add logger bindings after imports (they need import logging to be present) *)
      let pre_definition =
        if logger_lines = "" then imports_section
        else imports_section ^ "\n" ^ logger_lines
      in
      let content = pre_definition ^ "\n\n" ^ trimmed in
      let filename = Prefix.generate_filename ~prefix_kind defn in
      { Types.relative_path = filename; content }
    ) definitions
  in
  let init_file = build_init_file ~source_name ~docstring:import_result.docstring ~prefix_kind definitions in
  let constants_file = build_constants_file ~import_block ~constants ~definitions ~prefix_kind in
  let constant_refs = detect_constant_references source definitions in
  let all_output_files =
    let base = output_files @ [init_file] in
    match constants_file with
    | Some cf -> base @ [cf]
    | None -> base
  in
  let plan = { Types.source_name; definitions; output_files = all_output_files } in
  (plan, import_result.skipped_docstring, import_result.skipped_pragmas, potential_reexports, constant_refs)

(** Build warning messages for skipped content and potential issues.
    @param warn_docstring Only warn about docstrings for incremental extraction
           (full atomization preserves docstring in __init__.py) *)
let build_warnings skipped_docstring skipped_pragmas potential_reexports constant_refs ~preserve_reexports ~warn_docstring =
  let warnings = [] in
  let warnings = if skipped_docstring && warn_docstring then
    "⚠ Module docstring was NOT copied to extracted file.\n  Review the original and add manually if needed." :: warnings
  else warnings in
  let warnings = if skipped_pragmas then
    "⚠ Pragma comments (# mypy:, # type:, etc.) were skipped.\n  Use --keep-pragmas to include them." :: warnings
  else warnings in
  let warnings = if potential_reexports <> [] then
    let names = List.map (fun (imp : Extract.parsed_import) ->
      Printf.sprintf "  - %s (from %s)" imp.name imp.module_path
    ) potential_reexports in
    let warning =
      if preserve_reexports then
        Printf.sprintf
          "⚠ Potential re-exports detected (--preserve-reexports enabled, consumers NOT fixed).\n\
           The following imports won't be available from the generated __init__.py:\n%s\n\
           If other code imports these from this module, update those imports manually."
          (String.concat "\n" names)
      else
        Printf.sprintf
          "⚠ Potential broken re-exports detected.\n\
           The following imports won't be available from the generated __init__.py:\n%s\n\
           If other code imports these from this module, update those imports\n\
           to use the original source instead."
          (String.concat "\n" names)
    in
    warning :: warnings
  else warnings in
  (* constant_refs warning removed - constants are now extracted to _constants.py *)
  let _ = constant_refs in
  List.rev warnings

(** Run atomization *)
let run_atomize source_path output_dir dry_run format_opt keep_pragmas manifest_opt preserve_reexports keep_original prefix_kind =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in
    let source_name = Filename.basename source_path in
    let (plan, skipped_docstring, skipped_pragmas, potential_reexports, constant_refs) = plan_atomization source source_name ~keep_pragmas ~prefix_kind in

    if plan.definitions = [] then begin
      print_endline (Printf.sprintf "No definitions found in %s" source_path);
      0
    end else begin
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None ->
          let stem = Filename.remove_extension source_path in
          stem
      in

      (* Track import fix result for reporting *)
      let import_fix_result = ref None in

      if not dry_run then begin
        List.iter (fun (f : Types.output_file) ->
          let path = Filename.concat resolved_output_dir f.relative_path in
          write_file path f.content
        ) plan.output_files;
        (* Always generate manifest - essential for preserving original order *)
        let manifest_format = Option.value manifest_opt ~default:"yaml" in
        let (content, filename) = Render.manifest ~format:manifest_format ~source_name ~prefix_kind ~definitions:plan.definitions in
        let path = Filename.concat resolved_output_dir filename in
        write_file path content;
        (* Clean up unused imports with ruff *)
        cleanup_unused_imports resolved_output_dir;

        (* Fix consumer imports that relied on re-exports (unless --preserve-reexports) *)
        if potential_reexports <> [] && not preserve_reexports then begin
          let defined_names = List.map (fun (d : Types.definition) -> d.name) plan.definitions in
          let reexports = List.map (fun (imp : Extract.parsed_import) ->
            (imp.name, imp.module_path)
          ) potential_reexports in
          let abs_source_path =
            if Filename.is_relative source_path then
              Filename.concat (Sys.getcwd ()) source_path
            else source_path
          in
          import_fix_result := Some (Rewrite.fix_consumer_imports
            ~atomized_file:abs_source_path
            ~defined_names
            ~reexports)
        end
      end;

      let output = match format_opt with
        | "json" -> Render.plan_json plan
        | _ ->
          let text = Render.plan_text plan in
          if dry_run then
            text ^ "\n\n[DRY RUN] No files written."
          else
            text ^ Printf.sprintf "\n\nCreated %d files in %s/"
              (List.length plan.output_files) resolved_output_dir
      in
      print_endline output;

      (* Print warnings at the end *)
      let warnings = build_warnings skipped_docstring skipped_pragmas potential_reexports constant_refs ~preserve_reexports ~warn_docstring:false in
      if warnings <> [] then begin
        print_endline "";
        List.iter print_endline warnings
      end;

      (* Report import fix results *)
      (match !import_fix_result with
       | None -> ()
       | Some (Rewrite.Fixed { rewrites = _; files_changed; details }) ->
         if files_changed > 0 then begin
           print_endline (Printf.sprintf "\n✓ Fixed imports in %d consumer file(s):" files_changed);
           List.iter (fun (detail : Rewrite.import_fix_detail) ->
             print_endline (Printf.sprintf "  %s:" detail.file_path);
             List.iter (fun (name, _from_mod, to_mod) ->
               print_endline (Printf.sprintf "    %s → %s" name to_mod)
             ) detail.names_moved
           ) details
         end
       | Some (Rewrite.StarImportError { file; line }) ->
         print_endline (Printf.sprintf "\n⚠ Cannot fix imports: star import at %s:%d\n  Manual update required." file line)
       | Some (Rewrite.Error msg) ->
         print_endline (Printf.sprintf "\n⚠ Import fix error: %s" msg));

      (* Handle original file: remove if safe, keep otherwise *)
      if not dry_run then
        handle_original_file ~keep_original source_path;
      0
    end
  end

(** Helper to split source into lines *)
let source_to_lines source =
  let parts = String.split_on_char '\n' source in
  let parts =
    if String.length source > 0 && source.[String.length source - 1] = '\n' then
      match List.rev parts with
      | "" :: rest -> List.rev rest
      | _ -> parts
    else parts
  in
  List.map (fun s -> s ^ "\n") parts

(** Run single extraction *)
let run_extract source_path name output_dir dry_run format_opt keep_pragmas =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in

    (* Get import metadata for warnings *)
    let lines = source_to_lines source in
    let import_result = Extract.extract_imports_full ~keep_pragmas lines in

    match Extract.extract_one source name with
    | None ->
      print_endline (Render.error (Printf.sprintf "Definition '%s' not found in %s" name source_path));
      1
    | Some result ->
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None -> Sys.getcwd ()
      in

      if not dry_run then begin
        let path = Filename.concat resolved_output_dir result.extracted.relative_path in
        write_file path result.extracted.content;
        (* Create __init__.py if it doesn't exist *)
        let init_path = Filename.concat resolved_output_dir "__init__.py" in
        if not (Sys.file_exists init_path) then
          write_file init_path (build_single_init name);
        (* Clean up unused imports with ruff *)
        cleanup_unused_imports resolved_output_dir
      end;

      let output = match format_opt with
        | "json" -> Render.extraction_json result ~name
        | _ -> Render.extraction_text result ~name ~dry_run
      in
      print_endline output;

      (* Print warnings at the end - no re-export warnings for single extraction *)
      let warnings = build_warnings import_result.skipped_docstring import_result.skipped_pragmas [] [] ~preserve_reexports:false ~warn_docstring:true in
      if warnings <> [] then begin
        print_endline "";
        List.iter print_endline warnings
      end;
      0
  end

(** Run list mode - show definitions without atomizing *)
let run_list source_path format_opt organized =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in
    let source_name = Filename.basename source_path in
    let definitions = Extract.extract_definitions source in

    let output = match format_opt with
      | "json" -> Render.list_json definitions ~source_name
      | _ -> Render.list_text definitions ~source_name ~organized
    in
    print_endline output;
    0
  end

(** Main entry point *)
let main source_path output_dir dry_run format_opt extract_name keep_pragmas list_mode organized manifest_opt preserve_reexports keep_original no_prefix_kind =
  let prefix_kind = not no_prefix_kind in
  match list_mode, extract_name with
  | true, _ -> run_list source_path format_opt organized
  | false, Some name -> run_extract source_path name output_dir dry_run format_opt keep_pragmas
  | false, None -> run_atomize source_path output_dir dry_run format_opt keep_pragmas manifest_opt preserve_reexports keep_original prefix_kind

(* Cmdliner terms *)

let source_arg =
  let doc = "Source file to atomize" in
  Arg.(required & pos 0 (some string) None & info [] ~docv:"SOURCE" ~doc)

let output_arg =
  let doc = "Output directory (default: <source_stem>/)" in
  Arg.(value & opt (some string) None & info ["o"; "output"] ~docv:"DIR" ~doc)

let dry_run_arg =
  let doc = "Show what would be created without writing files" in
  Arg.(value & flag & info ["dry-run"] ~doc)

let format_arg =
  let doc = "Output format (text or json)" in
  Arg.(value & opt string "text" & info ["format"] ~docv:"FORMAT" ~doc)

let extract_arg =
  let doc = "Extract a single definition by name (incremental mode)" in
  Arg.(value & opt (some string) None & info ["extract"] ~docv:"NAME" ~doc)

let keep_pragmas_arg =
  let doc = "Keep file-level pragma comments (# mypy:, # type:, etc.) in extracted files" in
  Arg.(value & flag & info ["keep-pragmas"] ~doc)

let list_arg =
  let doc = "List all definitions without atomizing" in
  Arg.(value & flag & info ["list"] ~doc)

let organized_arg =
  let doc = "Group definitions by kind (only with --list)" in
  Arg.(value & flag & info ["organized"] ~doc)

let manifest_arg =
  let doc = "Generate manifest file preserving original definition order. Format: yaml, json, or md" in
  Arg.(value & opt (some string) None & info ["manifest"] ~docv:"FORMAT" ~doc)

let preserve_reexports_arg =
  let doc = "Skip fixing consumer imports. Use when re-exports are intentional (library code with external consumers)." in
  Arg.(value & flag & info ["preserve-reexports"] ~doc)

let keep_original_arg =
  let doc = "Keep original file after atomization. By default, the original is removed if it's git-tracked with no uncommitted changes." in
  Arg.(value & flag & info ["keep-original"] ~doc)

let no_prefix_kind_arg =
  let doc = "Don't prefix filenames with definition kind (default: prefixed)" in
  Arg.(value & flag & info ["no-prefix-kind"] ~doc)

(* ============================================================================
   Lint subcommand
   ============================================================================ *)

(** Read file contents, return None on error *)
let read_file_opt path =
  try Some (read_file path)
  with _ -> None

(** Run lint on a directory *)
let run_lint dir_path =
  if not (Sys.file_exists dir_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" dir_path));
    1
  end else if not (Sys.is_directory dir_path) then begin
    print_endline (Render.error (Printf.sprintf "%s is not a directory" dir_path));
    1
  end else
    match Lint.lint_directory ~dir:dir_path ~read_file:read_file_opt with
    | Lint.AllClean count ->
      print_endline (Printf.sprintf "✓ All %d files OK" count);
      0
    | Lint.Issues issues ->
      List.iter (fun (issue : Lint.lint_issue) ->
        let expected = String.concat "|" (List.map Render.kind_to_string issue.expected_kinds) in
        let actual = Render.kind_to_string issue.actual_kind in
        print_endline (Printf.sprintf "%s:%d: expected %s, found %s (%s)"
          issue.file_path issue.line expected actual issue.definition_name)
      ) issues;
      print_endline (Printf.sprintf "\n✗ %d issue(s) found" (List.length issues));
      1
    | Lint.Error msg ->
      print_endline (Render.error msg);
      1

let lint_dir_arg =
  let doc = "Directory to lint (must be an atomized directory)" in
  Arg.(required & pos 0 (some string) None & info [] ~docv:"DIR" ~doc)

let lint_cmd =
  let doc = "Check that filenames match definition kinds (use after --prefix-kind)" in
  let info = Cmd.info "lint" ~doc in
  let term = Term.(const run_lint $ lint_dir_arg) in
  Cmd.v info term

(* ============================================================================
   Main command group
   ============================================================================ *)

let atomize_cmd =
  let doc = "Atomize a Python source file" in
  let info = Cmd.info "atomize" ~doc in
  let term = Term.(const main $ source_arg $ output_arg $ dry_run_arg $ format_arg $ extract_arg $ keep_pragmas_arg $ list_arg $ organized_arg $ manifest_arg $ preserve_reexports_arg $ keep_original_arg $ no_prefix_kind_arg) in
  Cmd.v info term

let cmd =
  let doc = "Atomize Python source files into one-definition-per-file structure" in
  let info = Cmd.info "atomyst" ~version ~doc in
  Cmd.group info ~default:(Term.(const main $ source_arg $ output_arg $ dry_run_arg $ format_arg $ extract_arg $ keep_pragmas_arg $ list_arg $ organized_arg $ manifest_arg $ preserve_reexports_arg $ keep_original_arg $ no_prefix_kind_arg)) [atomize_cmd; lint_cmd]

let () =
  match Cmd.eval_value cmd with
  | Ok (`Ok exit_code) -> exit exit_code
  | Ok `Version | Ok `Help -> exit 0
  | Error _ -> exit 1
