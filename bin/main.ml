(** Atomyst CLI entry point.

    Atomize Python source files into one-definition-per-file structure.
*)

open Cmdliner
open Atomyst

let version = "%%VERSION_NUM%%"

(** Read file contents *)
let read_file path =
  let ic = open_in path in
  let n = in_channel_length ic in
  let s = really_input_string ic n in
  close_in ic;
  s

(** Write file contents, creating parent directories if needed *)
let write_file path content =
  let dir = Filename.dirname path in
  if not (Sys.file_exists dir) then
    ignore (Sys.command (Printf.sprintf "mkdir -p %s" (Filename.quote dir)));
  let oc = open_out path in
  output_string oc content;
  close_out oc

(** Run ruff to clean up unused imports. Silent if ruff not available. *)
let cleanup_unused_imports dir =
  let cmd = Printf.sprintf "ruff check --fix --select=F401 %s >/dev/null 2>&1"
    (Filename.quote dir) in
  ignore (Sys.command cmd)

(** Build __init__.py content for a single definition by name *)
let build_single_init name =
  let buf = Buffer.create 256 in
  Buffer.add_string buf {|"""Auto-generated by atomyst."""|};
  Buffer.add_string buf "\n\n";
  let stem = Snake_case.to_snake_case name in
  Buffer.add_string buf (Printf.sprintf "from .%s import %s\n" stem name);
  Buffer.add_string buf "\n__all__ = [\n";
  Buffer.add_string buf (Printf.sprintf "    \"%s\",\n" name);
  Buffer.add_string buf "]\n";
  Buffer.contents buf

(** Build __init__.py content for a list of definitions *)
let build_init_file definitions =
  let buf = Buffer.create 256 in
  Buffer.add_string buf {|"""Auto-generated by atomyst."""|};
  Buffer.add_string buf "\n\n";
  List.iter (fun (d : Types.definition) ->
    let stem = Snake_case.to_snake_case d.name in
    Buffer.add_string buf (Printf.sprintf "from .%s import %s\n" stem d.name)
  ) definitions;
  Buffer.add_string buf "\n__all__ = [\n";
  List.iter (fun (d : Types.definition) ->
    Buffer.add_string buf (Printf.sprintf "    \"%s\",\n" d.name)
  ) definitions;
  Buffer.add_string buf "]\n";
  { Types.relative_path = "__init__.py"; content = Buffer.contents buf }

(** Detect potential re-exports: names imported but not defined.
    These won't be available from the generated __init__.py. *)
let detect_potential_reexports import_lines definitions =
  let parsed = Extract.parse_import_names import_lines in
  let defined_names = List.map (fun (d : Types.definition) -> d.name) definitions in
  (* Filter to non-relative imports that could be re-exported *)
  List.filter (fun (imp : Extract.parsed_import) ->
    (* Exclude relative imports - those are internal *)
    not imp.is_relative &&
    (* Exclude if it matches a definition name *)
    not (List.mem imp.name defined_names)
  ) parsed

(** Plan atomization of a source file. Returns (plan, skipped_docstring, skipped_pragmas, potential_reexports) *)
let plan_atomization source source_name ~keep_pragmas =
  let lines =
    let parts = String.split_on_char '\n' source in
    let parts =
      if String.length source > 0 && source.[String.length source - 1] = '\n' then
        match List.rev parts with
        | "" :: rest -> List.rev rest
        | _ -> parts
      else parts
    in
    List.map (fun s -> s ^ "\n") parts
  in
  let definitions = Extract.extract_definitions source in
  let import_result = Extract.extract_imports_full ~keep_pragmas lines in
  let potential_reexports = detect_potential_reexports import_result.lines definitions in
  (* Adjust relative imports: when extracting foo.py to foo/, we go 1 level deeper *)
  let adjusted_lines = Extract.adjust_relative_imports ~depth_delta:1 import_result.lines in
  let import_block = String.concat "" adjusted_lines in

  let output_files =
    List.map (fun (defn : Types.definition) ->
      let arr = Array.of_list lines in
      let actual_start =
        (* find_comment_start logic *)
        let rec scan idx =
          if idx < 0 then idx + 2
          else
            let stripped = String.trim arr.(idx) in
            if String.length stripped > 0 && stripped.[0] = '#' then scan (idx - 1)
            else if stripped = "" then idx + 2
            else idx + 2
        in
        scan (defn.start_line - 2)
      in
      let defn_lines =
        Array.sub arr (actual_start - 1) (defn.end_line - actual_start + 1)
        |> Array.to_list
      in
      let defn_content = String.concat "" defn_lines in
      (* Find sibling references and generate imports *)
      let sibling_names = Extract.find_sibling_references ~all_defns:definitions ~target_defn:defn ~defn_content in
      let sibling_import_lines = Extract.generate_sibling_imports sibling_names in
      let sibling_imports = String.concat "" sibling_import_lines in
      let trimmed =
        let s = defn_content in
        let len = String.length s in
        let rec find_start i =
          if i >= len then len
          else if s.[i] = '\n' then find_start (i + 1)
          else i
        in
        String.sub s (find_start 0) (len - find_start 0)
      in
      (* Combine: original imports + sibling imports + definition *)
      let imports_section =
        if sibling_imports = "" then import_block
        else import_block ^ sibling_imports
      in
      let content = imports_section ^ "\n\n" ^ trimmed in
      let filename = Snake_case.to_snake_case defn.name ^ ".py" in
      { Types.relative_path = filename; content }
    ) definitions
  in
  let init_file = build_init_file definitions in
  let plan = { Types.source_name; definitions; output_files = output_files @ [init_file] } in
  (plan, import_result.skipped_docstring, import_result.skipped_pragmas, potential_reexports)

(** Build warning messages for skipped content and potential issues *)
let build_warnings skipped_docstring skipped_pragmas potential_reexports =
  let warnings = [] in
  let warnings = if skipped_docstring then
    "⚠ Module docstring was NOT copied to extracted files.\n  Review the original and distribute manually if needed." :: warnings
  else warnings in
  let warnings = if skipped_pragmas then
    "⚠ Pragma comments (# mypy:, # type:, etc.) were skipped.\n  Use --keep-pragmas to include them." :: warnings
  else warnings in
  let warnings = if potential_reexports <> [] then
    let names = List.map (fun (imp : Extract.parsed_import) ->
      Printf.sprintf "  - %s (from %s)" imp.name imp.module_path
    ) potential_reexports in
    let warning = Printf.sprintf
      "⚠ Potential broken re-exports detected.\n\
       The following imports won't be available from the generated __init__.py:\n%s\n\
       If other code imports these from this module, update those imports\n\
       to use the original source instead."
      (String.concat "\n" names)
    in
    warning :: warnings
  else warnings in
  List.rev warnings

(** Run atomization *)
let run_atomize source_path output_dir dry_run format_opt keep_pragmas manifest_opt =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in
    let source_name = Filename.basename source_path in
    let (plan, skipped_docstring, skipped_pragmas, potential_reexports) = plan_atomization source source_name ~keep_pragmas in

    if plan.definitions = [] then begin
      print_endline (Printf.sprintf "No definitions found in %s" source_path);
      0
    end else begin
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None ->
          let stem = Filename.remove_extension source_path in
          stem
      in

      if not dry_run then begin
        List.iter (fun (f : Types.output_file) ->
          let path = Filename.concat resolved_output_dir f.relative_path in
          write_file path f.content
        ) plan.output_files;
        (* Generate manifest if requested *)
        (match manifest_opt with
         | Some format ->
           let (content, filename) = Render.manifest ~format ~source_name ~definitions:plan.definitions in
           let path = Filename.concat resolved_output_dir filename in
           write_file path content
         | None -> ());
        (* Clean up unused imports with ruff *)
        cleanup_unused_imports resolved_output_dir
      end;

      let output = match format_opt with
        | "json" -> Render.plan_json plan
        | _ ->
          let text = Render.plan_text plan in
          if dry_run then
            text ^ "\n\n[DRY RUN] No files written."
          else
            text ^ Printf.sprintf "\n\nCreated %d files in %s/"
              (List.length plan.output_files) resolved_output_dir
      in
      print_endline output;

      (* Print warnings at the end *)
      let warnings = build_warnings skipped_docstring skipped_pragmas potential_reexports in
      if warnings <> [] then begin
        print_endline "";
        List.iter print_endline warnings
      end;
      0
    end
  end

(** Helper to split source into lines *)
let source_to_lines source =
  let parts = String.split_on_char '\n' source in
  let parts =
    if String.length source > 0 && source.[String.length source - 1] = '\n' then
      match List.rev parts with
      | "" :: rest -> List.rev rest
      | _ -> parts
    else parts
  in
  List.map (fun s -> s ^ "\n") parts

(** Run single extraction *)
let run_extract source_path name output_dir dry_run format_opt keep_pragmas =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in

    (* Get import metadata for warnings *)
    let lines = source_to_lines source in
    let import_result = Extract.extract_imports_full ~keep_pragmas lines in

    match Extract.extract_one source name with
    | None ->
      print_endline (Render.error (Printf.sprintf "Definition '%s' not found in %s" name source_path));
      1
    | Some result ->
      let resolved_output_dir = match output_dir with
        | Some dir -> dir
        | None -> Sys.getcwd ()
      in

      if not dry_run then begin
        let path = Filename.concat resolved_output_dir result.extracted.relative_path in
        write_file path result.extracted.content;
        (* Create __init__.py if it doesn't exist *)
        let init_path = Filename.concat resolved_output_dir "__init__.py" in
        if not (Sys.file_exists init_path) then
          write_file init_path (build_single_init name);
        (* Clean up unused imports with ruff *)
        cleanup_unused_imports resolved_output_dir
      end;

      let output = match format_opt with
        | "json" -> Render.extraction_json result ~name
        | _ -> Render.extraction_text result ~name ~dry_run
      in
      print_endline output;

      (* Print warnings at the end - no re-export warnings for single extraction *)
      let warnings = build_warnings import_result.skipped_docstring import_result.skipped_pragmas [] in
      if warnings <> [] then begin
        print_endline "";
        List.iter print_endline warnings
      end;
      0
  end

(** Run list mode - show definitions without atomizing *)
let run_list source_path format_opt organized =
  if not (Sys.file_exists source_path) then begin
    print_endline (Render.error (Printf.sprintf "%s does not exist" source_path));
    1
  end else begin
    let source = read_file source_path in
    let source_name = Filename.basename source_path in
    let definitions = Extract.extract_definitions source in

    let output = match format_opt with
      | "json" -> Render.list_json definitions ~source_name
      | _ -> Render.list_text definitions ~source_name ~organized
    in
    print_endline output;
    0
  end

(** Main entry point *)
let main source_path output_dir dry_run format_opt extract_name keep_pragmas list_mode organized manifest_opt =
  match list_mode, extract_name with
  | true, _ -> run_list source_path format_opt organized
  | false, Some name -> run_extract source_path name output_dir dry_run format_opt keep_pragmas
  | false, None -> run_atomize source_path output_dir dry_run format_opt keep_pragmas manifest_opt

(* Cmdliner terms *)

let source_arg =
  let doc = "Source file to atomize" in
  Arg.(required & pos 0 (some string) None & info [] ~docv:"SOURCE" ~doc)

let output_arg =
  let doc = "Output directory (default: <source_stem>/)" in
  Arg.(value & opt (some string) None & info ["o"; "output"] ~docv:"DIR" ~doc)

let dry_run_arg =
  let doc = "Show what would be created without writing files" in
  Arg.(value & flag & info ["dry-run"] ~doc)

let format_arg =
  let doc = "Output format (text or json)" in
  Arg.(value & opt string "text" & info ["format"] ~docv:"FORMAT" ~doc)

let extract_arg =
  let doc = "Extract a single definition by name (incremental mode)" in
  Arg.(value & opt (some string) None & info ["extract"] ~docv:"NAME" ~doc)

let keep_pragmas_arg =
  let doc = "Keep file-level pragma comments (# mypy:, # type:, etc.) in extracted files" in
  Arg.(value & flag & info ["keep-pragmas"] ~doc)

let list_arg =
  let doc = "List all definitions without atomizing" in
  Arg.(value & flag & info ["list"] ~doc)

let organized_arg =
  let doc = "Group definitions by kind (only with --list)" in
  Arg.(value & flag & info ["organized"] ~doc)

let manifest_arg =
  let doc = "Generate manifest file preserving original definition order. Format: yaml, json, or md" in
  Arg.(value & opt (some string) None & info ["manifest"] ~docv:"FORMAT" ~doc)

let cmd =
  let doc = "Atomize Python source files into one-definition-per-file structure" in
  let info = Cmd.info "atomyst" ~version ~doc in
  let term = Term.(const main $ source_arg $ output_arg $ dry_run_arg $ format_arg $ extract_arg $ keep_pragmas_arg $ list_arg $ organized_arg $ manifest_arg) in
  Cmd.v info term

let () =
  match Cmd.eval_value cmd with
  | Ok (`Ok exit_code) -> exit exit_code
  | Ok `Version | Ok `Help -> exit 0
  | Error _ -> exit 1
